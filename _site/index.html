<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <meta name="description" content="Development of a Secure Wallet : using Qt and the SEcube platform">

    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Development of a Secure Wallet | using Qt and the SEcube platform</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Development of a Secure Wallet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="using Qt and the SEcube platform" />
<meta property="og:description" content="using Qt and the SEcube platform" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="Development of a Secure Wallet" />
<script type="application/ld+json">
{"name":"Development of a Secure Wallet","description":"using Qt and the SEcube platform","@type":"WebSite","url":"http://localhost:4000/","headline":"Development of a Secure Wallet","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="">View on GitHub</a>

          <h1 id="project_title">Development of a Secure Wallet</h1>
          <h2 id="project_tagline">using Qt and the SEcube platform</h2>

          
            <section id="downloads">
              <a class="zip_download_link" href="">Download this project as a .zip file</a>
              <a class="tar_download_link" href="">Download this project as a tar.gz file</a>
            </section>
          
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><a href="another-page">Authors Bio</a></p>

<p><em>Digital passwords are among the most sensitive data one person or organization can have. They protect private information ranging from personal files to bank accounts, and if stolen, the consequences can be catastrophic. In this work we develop a Qt application, SECubeWallet, able to secure any number of passwords, relaying on the encryption power provided by the SEcube platform, which uses a software password together with Hardware keys existing in a small and portable device, making the hacking of the secured data virtually impossible. The main additional feature offered is a realistic password strength estimation using the zxcvbn dropbox project.</em></p>

<h1 id="secube-open-security-platform"><a href="#header-1"></a>SECUBE OPEN SECURITY PLATFORM</h1>

<p>The core of our implementation is the SEcube Platform.</p>
<blockquote>
  <p>The SEcube (Secure Environment cube) Open Security Platform is an open source security oriented hardware and software platform, designed and constructed with ease of integration and service-orientation in mind. The hardware part of the platform was originally designed by Blu5 Group1, whereas the software libraries stem from a strong cooperation among international research institutions.</p>
</blockquote>

<blockquote>
  <p>The software libraries and design environment allow developers who are not willing or able to produce the security APIs and protocols themselves to exploit the ready functions provided (currently as APIs and soon as services) within the SEcube platform and experience the platform as a high-security black box.</p>
</blockquote>

<h4 id="hardware-device-family"><a href="#header-4"></a>Hardware device family</h4>
<p>The SECube device family comprise three major members:</p>
<ul>
  <li><strong>The Chip</strong>, named SEcube Chip, or simply SEcube.</li>
  <li><strong>The Development Board</strong>, named SEcube DevKit.</li>
  <li><strong>The USB Stick</strong>, named USEcube Stick.</li>
</ul>

<p>In our project we used the Development Board provided by the professors, already configured to our needs. For thefinal user the board would be of course too inconvenient to carry, and instead the USEcube Stick would be preferred.</p>

<h4 id="l2-security-apis"><a href="#header-4"></a>L2 Security APIs</h4>

<p>From the user/developer point of view, the APIs have been implemented targeting two nested environments depending on where physically the code runs:</p>
<ul>
  <li><strong>Device-Side</strong>, including the libraries of basic functionalities that are executed on the embedded processor of the SEcube-based hardware device.</li>
  <li><strong>Host-Side</strong>, containing libraries of functions executed on the host PC and interface functions for calling services and processes residing on the embedded processor of the SEcube device.</li>
</ul>

<p>From the architectural point of view, the Host-Side Libraries have been implemented targeting 4 hierarchical abstraction levels, and namely:</p>
<ul>
  <li><strong>Level 0</strong>: Communication Protocol and Provisioning APIs.</li>
  <li><strong>Level 1</strong>: Basic Security APIs (Level1 Host-Side L1).</li>
  <li><strong>Level 2</strong>: Intermediate Security APIs (Level2 L2).</li>
  <li><strong>Level 3</strong>: Advanced Security APIs (Level3 L3).</li>
</ul>

<p>L2 can be considered as the merge of two projects: SEfile, concerning data at rest, and SElink, concerning instead data at motion.</p>

<blockquote>
  <p>SEfile targets any user that, by moving inside a secure environment, wants to perform basic operation on regular files. It must be pointed out that all encryption functionalities are demanded to the secure device in their entirety. In addition, SEfile does not expose to the host device details about what, or where it is reading/writing data: thus, the host OS, which might be untrusted, is totally unaware of what it is writing</p>
</blockquote>

<h1 id="qt"><a href="#header-1"></a>QT</h1>

<p>Our applicationâ€™s graphical interface was developed using the Qt framework.</p>
<blockquote>
  <p>Qt is a cross-platform application development framework for desktop, embedded and mobile. Supported Platforms include Linux, OS X, Windows, VxWorks, QNX, Android, iOS, BlackBerry, Sailfish OS and others. Qt is not a programming language on its own. It is a framework written in C++. A preprocessor, the MOC (Meta-Object Compiler), is used to extend the C++ language with features like signals and slots. Before the compilation step, the MOC parses the source files written in Qt-extended C++ and generates standard compliant C++ sources from them. Thus the framework itself and applications/libraries using it can be compiled by any standard compliant C++ compiler like Clang, GCC, ICC, MinGW and MSVC</p>
</blockquote>

<h4 id="qt-creator"><a href="#header-4"></a>Qt creator</h4>

<p>For development we used the IDE Qt Creator.</p>
<blockquote>
  <p>Qt Creator provides a cross-platform, complete integrated development environment (IDE) for application developers to create applications for multiple desktop, embedded, and mobile device platforms, such as Android and iOS. It is available for Linux, macOS and Windows operating systems</p>
</blockquote>

<p>Using Qt creator allowed us to implement easily and fast a robust and elegant solution to our problem. Thanks to the multitude of functions specially dedicated to the management of SQlite databases and display tables, we were able to focus or attention to solve other problems and to extend the functionalities of the project.</p>

<h1 id="zxcvbn-realistic-password-strength-estimation"><a href="#header-1"></a>ZXCVBN: Realistic Password Strength Estimation</h1>

<p>An important feature to final users is the possibility to realistically estimate how strong a password is, i.e., how hard could it be for hackers to crack it, as there is no point in using our system to protect weak passwords, that could be easily guessed with brute force attacks.</p>

<p>As it is out of our expertise to develop a reliable function to make this estimation, we preferred to use a trusted project coming from dropbox hackweek event in 2012. The estimator called zxcvbn was originally written in JavaScript aiming for an easy integration with multiple web browsers and OS.</p>

<blockquote>
  <p>For over 30 years, password requirements and feedback have largely remained a product of LUDS: counts of lowerand uppercase letters, digits and symbols. LUDS remains
ubiquitous despite being a conclusively burdensome and ineffective security practice. zxcvbn is an alternative password strength estimator that is small, fast, and crucially no harder than LUDS to adopt. Using leaked passwords, we compare its estimations to the best of four modern guessing attacks and show it to be accurate and conservative at low magnitudes, suitable for mitigating online attacks. We find 1.5 MB of compressed storage is sufficient to accurately estimate the best-known guessing attacks up to 105 guesses, or 104 and 103 guesses, respectively, given 245 kB and 29 kB. zxcvbn can be adopted with 4 lines of code and downloaded in seconds. It runs in milliseconds and works as-is on web, iOS and Android.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/duverleygrajales/SEcubeWallet/gh-pages/assets/images/password_strength.png" alt="" /></p>

<p>To put it in other words, the authors of the project argue that a password like <em>correcthorsebatterystaple</em> (a nonsense English phrase) is more strong than a password like <em>Tr0ub4dour&amp;3</em>, even if the former does not have any upper cases or numbers, and the latter seems more complicated.</p>

<blockquote>
  <p>People of course choose patterns dictionary words, spatial patterns like <em>qwerty</em>, <em>asdf</em> or <em>zxcvbn</em>, repeats like <em>aaaaaaa</em>, sequences like <em>abcdef</em> or <em>654321</em>, or some combination of the above. For passwords with uppercase letters, odds are its the first letter thats uppercase. Numbers and symbols are often predictable as well: <em>l33t</em> speak (3 for e, 0 for o, @ or 4 for a), years, dates, zip codes, and so on. As a result, simplistic strength estimation gives bad advice. Without checking for common patterns, the practice of encouraging numbers and symbols means encouraging passwords that might only be slightly harder for a computer to crack, and yet frustratingly harder for a human to remember. <em>xkcd</em> nailed it.</p>
</blockquote>

<h4 id="zxcvbn-and-qt-integration"><a href="#header-4"></a>zxcvbn and Qt integration</h4>
<p>First of all, we modified the <em>zxcvbn makefile</em>, to remove the unnecessary files and to understand how to proceed with the integration. It is necessary to compile said makefile in order to generate the <em>dictionary</em> used for passwords comparisons and entropy estimation. When we realized integration of the makefile with Qt was really cumbersome because Qt uses a qmake instead of a regular make, we decided to generate the source dictionary offline. Having the source dictionary ready, we included and modified the files <em>zxcvbn.cpp</em> and <em>zxcvbn.h</em> into our project. The modifications were necessary to use C++ libraries instead of C libraries.
Finally, with the files already integrated on the project, we just had to use function <em>ZxcvbnMatch(password)</em> to estimate the entropy and give the user a metric about how strong their password is.</p>

<h1 id="implementation"><a href="#header-1"></a>Implementation</h1>

<p>The basic idea behind our project is: We use the SEfile APIs to encrypt a file containing the passwords the user wants to protect. Said file is encrypted by the SEcube device connected to the computer, and can only be decrypted later if the same device is connected. The encryption/decryption can be done in any computer where an appropriate version of Qt is installed.</p>

<p>A detailed description of the usage workflow, functionalities and components is given below:</p>
<ol>
  <li>The user connects and mounts the SEcube device to the host computer.</li>
  <li>The user executes our application <strong>SEcubeWallet</strong></li>
  <li>The application ask for a master password, which has been previously configured into the SEcube device (in our case is <strong>test</strong>). The entered password has to coincide with the stored one to allow the login.</li>
</ol>

<p>After access is granted, the GUI shown in the figure allows the user to:</p>
<ol>
  <li>Create a new Wallet.</li>
  <li>Cypher the wallet, close it and delete the regular (insecure) file.</li>
  <li>Open an existent cyphered Wallet.</li>
  <li>Add/Edit a new entry to an existing Wallet. The user fills the required fields, and for the password there is strength measure feature.</li>
  <li>Delete an existing entry.</li>
  <li>Launch a web browser and open the selected domain.</li>
  <li>Edit the environment variables.</li>
  <li>Safe application close.</li>
</ol>

<p><img src="https://raw.githubusercontent.com/duverleygrajales/SEcubeWallet/gh-pages/assets/images/gui.png" alt="" /></p>

<h4 id="device-connection"><a href="#header-4"></a>Device connection</h4>

<p>The SEcube hardware devices SEcube DevKit and USEcube Stick can be easily connected to any pc host via USB ports. They appear in the system as a storage volume and need to be mounted in order to be used.</p>

<h4 id="secubewallet-execution"><a href="#header-4"></a>SEcubeWallet execution</h4>

<p>The application is executed as any standard QT application. The host pc requires then to have an appropriate version of Qt or Qt libraries installed and configured. To this moment, the version of Qt used for development is Qt 5.8.0.</p>

<h4 id="secure-login"><a href="#header-4"></a>Secure login</h4>

<p>For our project we used the Login dialogue from the example Secure Text Editor provided alongside with the L2 User Manual and shown in the figure. This dialogue opens a
secure connection with the SEcube device and as a result a <em>se3 session</em> pointer <em>s</em> is created. This pointer contains all the information that let the system acknowledge which board is connected and if the user has successfully logged in. After the board is connected and the user is correctly logged in, the <em>secure init()</em> function is issued.</p>

<p><img src="https://raw.githubusercontent.com/duverleygrajales/SEcubeWallet/gh-pages/assets/images/login.png" alt="" /></p>

<h4 id="create-a-new-wallet"><a href="#header-4"></a>Create a new Wallet</h4>

<p>Each wallet is stored as a table in a sqlite database, and is protected independently by a password. In this way the application supports multiple users working with the same SEcube device. This can be useful for companies that wish to protect the passwords of all of their employees, but keep their passwords separated from each other. The user enters the desired name and path using the dialogue shown in the figure, based on the example <em>Secure Text Editor</em>.</p>

<p><img src="https://raw.githubusercontent.com/duverleygrajales/SEcubeWallet/gh-pages/assets/images/create.png" alt="" /></p>

<p>The database is created with a <em>QSqlQuery</em> and the function <em>query.prepare</em> that allow us to execute sqlite commands. For the managing of the tables, we use a <em>QSqlTableModel</em> which simplifies the process by wrapping the sqlite functions. To display it in a <em>QTableView</em>, we connect the model to the view table, resulting in the flow <em>Sqltable-&gt;Model-&gt;TableView</em>.</p>

<h4 id="cypher-and-close"><a href="#header-4"></a>Cypher and close</h4>

<p>After the user has finished creating/editing the wallet, the Sqlite Database file containing the passwords needs to be cyphered using the SEcube device. This is possible using the <em>secure open</em>, <em>secure write</em> and <em>secure close</em> functions from the SEfile API. As a result, an encrypted version of the database file is created. Our implementation is based on the example <em>Secure Text Editor</em>.
After the file is encrypted we can proceed to close the database, delete the existing <em>plain</em> sqlite file, which is non secure, and close the <em>tableView</em> displaying the information. In this way, we are sure the passwords are safely stored in the encrypted file, and can only be read by the owner.</p>

<h4 id="open-existing-wallet"><a href="#header-4"></a>Open existing wallet</h4>

<p>To open cyphered wallets, the <em>Secure File Dialogue</em> from the <em>Secure Text Editor</em> example is used. This dialogue shows the user wallets in the current working directory that where previously encrypted using the connected SEcube device, as in the figure. The user then selects one of the wallets to be opened.</p>

<p><img src="https://raw.githubusercontent.com/duverleygrajales/SEcubeWallet/gh-pages/assets/images/open.png" alt="" /></p>

<p>With the selected cyphered file, and using the SEfile API functions <em>secure open</em>, <em>secure read</em> and <em>secure close</em>, a Sqlite file containing the stored passwords is created. Then a database connection to the file is opened and the entries are displayed in a Table View.</p>

<h4 id="addedit-entry-to-wallet"><a href="#header-4"></a>Add/Edit entry to wallet</h4>

<p>To Add or Edit a new entry to the wallet, the dialogue shown in figure was implemented.</p>

<p><img src="https://raw.githubusercontent.com/duverleygrajales/SEcubeWallet/gh-pages/assets/images/add.png" alt="" /></p>

<p>In this dialogue the user enters the required fields <em>username</em>, <em>domain</em> and <em>password</em>. The password has to be entered twice, to be sure is correct. Additionally, using <strong>zxcvbn</strong>, we estimate its strength and show it to the user with a progress bar. To edit, the user selects an entry, and clicks the <em>edit</em> button. The same dialogue is called, but with a different constructor, that initialize the fields with the current data.
To insert data to the tables, we use again our model and the function <em>model-&gt;insertRecord(Position, record)</em>, and to submit the changes <em>model-&gt;submitAll()</em>.</p>

<h4 id="delete-an-existing-entry"><a href="#header-4"></a>Delete an existing entry</h4>

<p>To delete an entry, the user just has to select one of the entries in the table and click the <em>delete</em> button. After this a confirmation prompt is shown warning the user an entry is about to be deleted forever. if the user clicks <em>ok</em>, the application proceeds to eliminate the data using the <em>removeRow</em> function from our model.</p>

<h4 id="launch-web-browser"><a href="#header-4"></a>Launch web browser</h4>

<p>If the user wishes to open in a web browser one of the domains in the wallet, it selects an entry and clicks the Launch button. Thanks to Qt function <em>QDesktopServices::OpenUrl(Qurl(string))</em> we only had to modify the domain field to include <em>http://</em> in the beginning of the string.</p>

<h4 id="edit-environment-variables"><a href="#header-4"></a>Edit environment variables</h4>

<p>This dialogue is intended for advanced users who would like to choose the algorithm and keys used for encryption in the SEcube device. Right now, with the device configuration provided by the professors, only one option is available.</p>

<h4 id="safe-close"><a href="#header-4"></a>Safe Close</h4>

<p>When the user decides to close the application, several actions need to be performed.</p>
<ul>
  <li>Encrypt file</li>
  <li>Delete Sqlite file</li>
  <li>Close the connection to the database
This is done by reusing the functions already developed for the cipher and close button.</li>
</ul>

<h1 id="improvements-and-future-work"><a href="#header-1"></a>Improvements and Future work</h1>

<h4 id="autofill-login-forms-in-website"><a href="#header-4"></a>Autofill login forms in website</h4>
<p>When the user clicks the launch button, not only the selected domain is opened, also, the login forms are autofilled using the stored username and password. We did not implemented this functionality as it requires HTML/CSS knowledge an it is out of the scope of the course.</p>

<h4 id="os-integration"><a href="#header-4"></a>OS integration</h4>
<p>Some OS, like linux distributions running the KDE Plasma Desktop already offer a wallet solution integrated in the system. Merging our project with these existing wallets could be a great feature for some users.</p>

<h4 id="browser-integration"><a href="#header-4"></a>Browser integration</h4>
<p>The vast majority of users store their passwords within their preferred web browser, alongside other sensitive information like browsing history and bookmarks. Using the capabilities of the SEcube security platform to protect all that data while maintaining ease of use and transparency to the final user would be a great advance. We did not investigate further in that direction, but we guess it is possible by developing a complement for the most popular web browsers (Firefox, Chrome, Opera) to run together with the main application.</p>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    
  </body>
</html>
